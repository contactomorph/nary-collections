using System.Collections;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using NaryMaps.Implementation;

namespace NaryMaps;

/// <summary>
/// Static class used to generate nary maps. A concrete type deriving from <see cref="Schema{TDataTuple}"/> must be
/// provided to specify the participants and constraints required on the nary map.
/// </summary>
public static class NaryMap
{
    private static ModuleBuilder? _moduleBuilder;
    
    /// <summary>
    /// Create a nary map from a provided schema.
    /// </summary>
    /// <typeparam name="TSchema">The schema encoding the participants and the constraints.</typeparam>
    /// <returns>An empty instance of nary maps corresponding to the provided schema.</returns>
    public static INaryMap<TSchema> New<TSchema>() where TSchema : Schema, new()
    {
        if (_moduleBuilder is null)
        {
            var guid = Guid.NewGuid();
            AssemblyName assembly = new AssemblyName { Name = $"nary_map_{guid:N}" };
            AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assembly, AssemblyBuilderAccess.Run);
            ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule("nary_map_module");

            Interlocked.CompareExchange(ref _moduleBuilder, moduleBuilder, null);
        }
        var factory = NaryMapCompilation<TSchema>.GenerateMapConstructor(_moduleBuilder);
        return factory();
    }
    
    /// <summary>
    /// Turn <paramref name="map"/> to a set of tuples.
    /// </summary>
    /// <param name="map">A given nary map generated by <see cref="New{TSchema}"/>.</param>
    /// <typeparam name="TDataTuple">The type of the tuple of participants.</typeparam>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public static IConflictingSet<TDataTuple> AsSet<TDataTuple>(
        this INaryMap<Schema<TDataTuple>> map)
        where TDataTuple : struct, ITuple, IStructuralEquatable
    {
        if (map is IConflictingSet<TDataTuple> set) return set;
        throw new InvalidOperationException("Unexpected map type.");
    }
    
    /// <summary>
    /// 
    /// </summary>
    /// <param name="map"></param>
    /// <typeparam name="TDataTuple"></typeparam>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public static IReadOnlyConflictingSet<TDataTuple> AsReadOnlySet<TDataTuple>(
        this IReadOnlyNaryMap<Schema<TDataTuple>> map)
        where TDataTuple : struct, ITuple, IStructuralEquatable
    {
        if (map is IReadOnlyConflictingSet<TDataTuple> set) return set;
        throw new InvalidOperationException("Unexpected map type.");
    }
}